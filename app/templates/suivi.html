<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GO-CHANTIER - Suivi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>
    <script src="https://unpkg.com/proj4@2.9.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <script src="https://unpkg.com/georaster@1.7.1/dist/georaster.browser.min.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.1.0/dist/georaster-layer-for-leaflet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <style>
      :root { --sky: #7ec8e3; --text:#000; --bg:#fff; }
      body { margin:0; display:flex; height:100vh; font-family: Arial, sans-serif; }
      * { font-size:14px; font-weight:700; }
      aside { width: 260px; background: var(--sky); color:#fff; display:flex; flex-direction:column; }
      .brand { padding: 14px 16px; font-size: 20px; font-weight: 800; background: rgba(255,255,255,0.1); }
      .project-name { padding: 10px 16px; background: rgba(0,0,0,0.08); color:#fff; }
      .nav { display:flex; flex-direction:column; gap: 6px; padding: 12px; }
      .nav button { background: rgba(255,255,255,0.2); color:#fff; border:none; padding: 10px; border-radius:8px; cursor:pointer; text-align:left; }
      main { flex:1; background:#f5f8fb; display:flex; flex-direction:column; }
      header { background: var(--sky); color:#fff; padding: 10px 16px; display:flex; justify-content: space-between; align-items:center; }
      header .right { display:flex; gap: 8px; }
      .btn { background:#0d6efd; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
      .content { padding: 12px; background:#fff; flex:1; margin: 12px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); overflow:auto; }
      .hidden { display:none; }
      #map { width: 100%; height: 70vh; background:#e9ecef; }
      .toolbar { display:flex; gap:10px; margin-bottom:10px; align-items:center; }
      input, select { padding: 8px; border: 1px solid #ccc; border-radius: 6px; background:#fff; color:#000; }
      label { color:#000; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .images-list { display:flex; gap:6px; flex-wrap:wrap; }
      .images-list img { width: 120px; height: 80px; object-fit: cover; border:2px solid #ddd; border-radius:6px; }
      .bubble { background:#fff; border: 1px solid #333; padding:6px 8px; border-radius: 12px; }
    </style>
  </head>
  <body>
    <aside>
      <div class="brand">GO-CHANTIER</div>
      <div class="project-name" id="projectName">Projet</div>
      <div class="nav">
        <button data-tab="viz">Visualisations</button>
        <button data-tab="analyse">Analyse</button>
        <button data-tab="courbes">Rapport courbe</button>
        <button data-tab="rapports">Rapports</button>
      </div>
    </aside>
    <main>
    <header>
        <div>Suivi de projet</div>
        <div class="right">
          <input type="number" id="progress" placeholder="% avancement" min="0" max="100" step="1" />
          <button class="btn" id="btn-save-progress">Enregistrer</button>
          <a class="btn" href="/">Projets</a>
        </div>
    </header>
      <div class="content">
        <section id="tab-viz">
          <div class="toolbar row">
            <form id="form-upload" class="row" onsubmit="return false;">
              <input type="file" id="file" accept=".tif,.tiff,.geotiff,.png,.jpg,.jpeg" />
              <input type="date" id="img-date" />
              <button class="btn" id="btn-upload">Importer</button>
            </form>
            <button class="btn" id="btn-zoom-in"><i class="fa fa-magnifying-glass-plus"></i></button>
            <button class="btn" id="btn-zoom-out"><i class="fa fa-magnifying-glass-minus"></i></button>
            <button class="btn" id="btn-measure-dist">Mesurer distance</button>
            <button class="btn" id="btn-measure-area">Mesurer surface</button>
            <button class="btn" id="btn-add-comment">Ajouter commentaire</button>
        </div>
        <div id="map"></div>
          <div class="images-list" id="thumbs"></div>
        </section>

        <section id="tab-analyse" class="hidden">
          <div class="row">
            <select id="img-a"></select>
            <select id="img-b"></select>
            <button class="btn" id="btn-calc">Calculer</button>
          </div>
          <div class="row" style="margin-top:10px; align-items:flex-start;">
            <img id="diff-out" style="max-width:48%; border:1px solid #ccc;" />
            <canvas id="pie" height="180" style="flex:1; max-width:48%;"></canvas>
          </div>
        </section>

        <section id="tab-courbes" class="hidden">
          <canvas id="chart" height="120"></canvas>
        </section>

        <section id="tab-rapports" class="hidden">
          <div class="row">
            <input type="file" id="doc-file" accept=".pdf,.doc,.docx,.xls,.xlsx" />
            <button class="btn" id="btn-doc-upload">Importer</button>
          </div>
          <div id="docs"></div>
      </section>
    </div>
    </main>

    <script>
      // Utilities
      const qs = new URLSearchParams(location.search);
      const projectId = qs.get('project_id');
      if(!projectId){ alert('project_id manquant'); }

      function $(id){ return document.getElementById(id); }
      async function fetchJSON(url){ const r = await fetch(url); return r.json(); }
      async function postJSON(url, data){ const r = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data)}); if(!r.ok) throw new Error('Erreur'); return r.json(); }

      // Tabs
      const tabs = { viz: $('tab-viz'), analyse: $('tab-analyse'), courbes: $('tab-courbes'), rapports: $('tab-rapports') };
      for(const btn of document.querySelectorAll('.nav button')){
        btn.onclick = ()=>{
          Object.values(tabs).forEach(s=> s.classList.add('hidden'));
          const tab = btn.dataset.tab;
          tabs[tab].classList.remove('hidden');
          if(tab === 'courbes') {
            updateChart();
          }
          if(tab === 'viz') {
            setTimeout(()=> map.invalidateSize(), 50);
          }
        };
      }

      // Map + GeoTIFF viewer
      let map = L.map('map').setView([0,0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM' }).addTo(map);
      let currentLayer = null;
      $('btn-zoom-in').onclick = ()=> map.zoomIn();
      $('btn-zoom-out').onclick = ()=> map.zoomOut();

      const _epsgCache = {};
      async function ensureProjDefinition(code){
        if(!code) return null;
        if(proj4 && proj4.defs && proj4.defs(code)) return code;
        if(_epsgCache[code]){ proj4.defs(code, _epsgCache[code]); return code; }
        try {
          const r = await fetch(`https://epsg.io/${code.replace('EPSG:','')}.proj4`);
          if(!r.ok) throw new Error('epsg.io ' + r.status);
          const def = (await r.text()).trim();
          if(def){ _epsgCache[code] = def; proj4.defs(code, def); return code; }
        } catch(e){ console.warn('EPSG fetch failed', e); }
        return null;
      }

      async function addGeoTIFF(url){
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if(!response.ok){ throw new Error('HTTP ' + response.status); }
          const arrayBuffer = await response.arrayBuffer();
          if(typeof parseGeoraster !== 'function') throw new Error('parseGeoraster indisponible');
          // Extract EPSG from GeoKeys
          let epsg = null, bbox = null;
          try {
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const keys = image.getGeoKeys?.() || {};
            const proj = keys.ProjectedCSTypeGeoKey || keys.GeographicTypeGeoKey;
            if(proj) epsg = `EPSG:${proj}`;
            if(image.getBoundingBox) bbox = image.getBoundingBox();
          } catch(e){ console.warn('GeoKeys read failed', e); }
          const georaster = await parseGeoraster(arrayBuffer);
          if(epsg) georaster.projection = epsg;
          if(epsg) await ensureProjDefinition(epsg);
          if(currentLayer){ map.removeLayer(currentLayer); }
          currentLayer = new GeoRasterLayer({ georaster, opacity: 1.0, resampleMethod: 'nearest' });
          currentLayer.addTo(map);
          try { map.fitBounds(currentLayer.getBounds()); } catch(e) { console.warn('fitBounds failed', e); }
        } catch (e){
          console.error('GeoTIFF error:', e);
          // Secondary fallback: render with geotiff.js to a canvas, then overlay with projected bounds if possible
          try {
            const response2 = await fetch(url, { cache: 'no-store' });
            const buf2 = await response2.arrayBuffer();
            const tiff = await GeoTIFF.fromArrayBuffer(buf2);
            const image = await tiff.getImage();
            const width = image.getWidth();
            const height = image.getHeight();
            let data = await image.readRasters({ interleave: true });
            // Downscale if too large
            const maxSide = Math.max(width, height);
            const scale = maxSide > 2048 ? 2048 / maxSide : 1;
            const outW = Math.max(1, Math.round(width * scale));
            const outH = Math.max(1, Math.round(height * scale));
            const canvas = document.createElement('canvas');
            canvas.width = outW; canvas.height = outH;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(outW, outH);
            const channels = image.getSamplesPerPixel();
            if(channels === 1){
              let min = Infinity, max = -Infinity;
              for(let i=0;i<data.length;i++){ const v=data[i]; if(v<min)min=v; if(v>max)max=v; }
              const norm = 255/(max-min || 1);
              for(let y=0;y<outH;y++){
                for(let x=0;x<outW;x++){
                  const srcX = Math.floor(x/scale); const srcY = Math.floor(y/scale);
                  const srcIdx = (srcY*width + srcX);
                  const v = Math.max(0, Math.min(255, Math.round((data[srcIdx]-min)*norm)));
                  const di = (y*outW + x)*4;
                  imgData.data[di]=v; imgData.data[di+1]=v; imgData.data[di+2]=v; imgData.data[di+3]=255;
                }
              }
            } else {
              const mins=[Infinity,Infinity,Infinity], maxs=[-Infinity,-Infinity,-Infinity];
              for(let i=0;i<data.length; i+=channels){
                for(let c=0;c<3;c++){ const v=data[i+c]; if(v<mins[c])mins[c]=v; if(v>maxs[c])maxs[c]=v; }
              }
              const norms=[0,0,0]; for(let c=0;c<3;c++){ norms[c] = 255/(maxs[c]-mins[c] || 1); }
              for(let y=0;y<outH;y++){
                for(let x=0;x<outW;x++){
                  const srcX = Math.floor(x/scale); const srcY = Math.floor(y/scale);
                  const si = (srcY*width + srcX)*channels;
                  const di = (y*outW + x)*4;
                  for(let c=0;c<3;c++){
                    const v = Math.max(0, Math.min(255, Math.round((data[si+c]-mins[c])*norms[c])));
                    imgData.data[di+c]=v;
                  }
                  imgData.data[di+3]=255;
                }
              }
            }
            ctx.putImageData(imgData, 0, 0);
            const dataUrl = canvas.toDataURL('image/png');
            // Try compute bounds from GeoTIFF bbox and EPSG
            let bounds = [[-60,-180],[60,180]];
            try {
              const keys = image.getGeoKeys?.() || {};
              const proj = keys.ProjectedCSTypeGeoKey || keys.GeographicTypeGeoKey;
              const code = proj ? `EPSG:${proj}` : null;
              if(code){
                await ensureProjDefinition(code);
                const bb = image.getBoundingBox?.();
                if(bb && Array.isArray(bb)){
                  const min = proj4(code, 'EPSG:4326', [bb[0], bb[1]]);
                  const max = proj4(code, 'EPSG:4326', [bb[2], bb[3]]);
                  bounds = [[min[1], min[0]],[max[1], max[0]]];
                }
              }
            } catch(e3){ console.warn('Bounds projection failed', e3); }
            if(currentLayer){ map.removeLayer(currentLayer); }
            currentLayer = L.imageOverlay(dataUrl, bounds).addTo(map);
            map.fitBounds(bounds);
          } catch (e2){
            console.error('Canvas fallback error:', e2);
            alert("Impossible d'afficher le GeoTIFF. Vérifiez le fichier.");
          }
        }
      }

      // Simple measure tools (control is added later)
      let measureMode = null; // 'dist' | 'area'
      let measurePoints = [];
      function resetMeasure(){ measureMode=null; measurePoints=[]; }
      const MeasureControl = L.Control.extend({
        options: { position: 'topleft' },
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'leaflet-bar');
          const btnDist = L.DomUtil.create('a', '', container);
          btnDist.href = '#';
          btnDist.title = 'Mesurer distance';
          btnDist.innerHTML = '<i class="fa fa-ruler"></i>';
          L.DomEvent.on(btnDist, 'click', L.DomEvent.stop)
                   .on(btnDist, 'mousedown', L.DomEvent.stop)
                   .on(btnDist, 'dblclick', L.DomEvent.stop)
                   .on(btnDist, 'click', function(){ resetMeasure(); measureMode='dist'; });
          const btnArea = L.DomUtil.create('a', '', container);
          btnArea.href = '#';
          btnArea.title = 'Mesurer surface';
          btnArea.innerHTML = '<i class="fa fa-draw-polygon"></i>';
          L.DomEvent.on(btnArea, 'click', L.DomEvent.stop)
                   .on(btnArea, 'mousedown', L.DomEvent.stop)
                   .on(btnArea, 'dblclick', L.DomEvent.stop)
                   .on(btnArea, 'click', function(){ resetMeasure(); measureMode='area'; });
          return container;
        }
      });
      map.addControl(new MeasureControl());
      map.on('click', (e)=>{
        if(!measureMode) return;
        measurePoints.push([e.latlng.lat, e.latlng.lng]);
        L.marker(e.latlng).addTo(map);
        if(measureMode==='dist' && measurePoints.length>=2){
          const a = measurePoints[measurePoints.length-2];
          const b = measurePoints[measurePoints.length-1];
          const d = map.distance(L.latLng(a[0],a[1]), L.latLng(b[0],b[1]));
          alert(`Distance: ${(d/1000).toFixed(3)} km`);
        }
        if(measureMode==='area' && measurePoints.length>=3){
          const poly = L.polygon(measurePoints);
          const area = L.GeometryUtil ? L.GeometryUtil.geodesicArea(poly.getLatLngs()[0]) : 0; // optional if plugin present
          alert(`Surface approx.: ${Math.round(area)} m²`);
        }
      });

      // Comments (bubbles)
      $('btn-add-comment').onclick = ()=>{
        alert('Cliquez sur la carte pour placer un commentaire');
        const handler = (e)=>{
          const text = prompt('Commentaire:');
          if(text){
            L.popup().setLatLng(e.latlng).setContent(`<div class='bubble'>${text}</div>`).openOn(map);
            // Persist annotation
            const imageId = currentImage?.id;
            if(imageId){ postJSON('/api/annotations', { image_id: imageId, text, lat: e.latlng.lat, lng: e.latlng.lng }).catch(console.error); }
          }
          map.off('click', handler);
        };
        map.on('click', handler);
      };

      // Images per project
      let images = [];
      let currentImage = null;
      async function loadImages(){
        images = await fetchJSON(`/api/images?project_id=${encodeURIComponent(projectId)}`);
        const thumbs = $('thumbs'); thumbs.innerHTML = '';
        images.sort((a,b)=> a.date > b.date ? 1 : -1);
        for(const img of images){
          const el = document.createElement('div');
          const dateLabel = document.createElement('div'); dateLabel.textContent = img.date;
          const imageEl = document.createElement('img'); imageEl.src = img.preview_url || img.url; imageEl.title = img.original_name || img.date; imageEl.onclick = ()=> showImage(img);
          el.appendChild(dateLabel); el.appendChild(imageEl);
          thumbs.appendChild(el);
        }
        if(images.length){ showImage(images[images.length-1]); }
        await updateProjectName();
        await updateChart();
        fillSelects();
        loadDocs();
      }

      function showImage(img){
        currentImage = img;
        $('projectName').textContent = currentProject?.name || 'Projet';
        const fname = img.filename.toLowerCase();
        if(fname.endsWith('.tif') || fname.endsWith('.tiff') || fname.endsWith('.geotiff')){
          addGeoTIFF(img.url);
        } else {
          if(currentLayer){ map.removeLayer(currentLayer); currentLayer=null; }
          try {
            const bounds = [[-45,-90],[45,90]];
            currentLayer = L.imageOverlay(img.url, bounds).addTo(map);
            map.fitBounds(bounds);
          } catch(e){
            const icon = L.icon({iconUrl: img.url, iconSize:[200,200]});
            L.marker([0,0], {icon}).addTo(map);
            map.setView([0,0], 2);
          }
        }
      }

      // Upload image
      $('btn-upload').onclick = async ()=>{
        const file = $('file').files[0];
        if(!file) return alert('Choisir un fichier');
        const fd = new FormData(); fd.append('file', file); fd.append('date', $('img-date').value || new Date().toISOString().slice(0,10)); fd.append('project_id', projectId);
        const r = await fetch('/api/images/upload', { method:'POST', body: fd });
        if(!r.ok) return alert('Echec upload');
        await r.json();
        loadImages();
      };

      // Project name and dates
      let currentProject = null;
      async function updateProjectName(){
        const projects = await fetchJSON('/api/projects');
        currentProject = projects.find(p=> p.id===projectId);
        $('projectName').textContent = currentProject ? currentProject.name : 'Projet';
      }

      // Progress
      $('btn-save-progress').onclick = async ()=>{
        const val = parseFloat($('progress').value || '0');
        await postJSON(`/api/projects/${projectId}/progress`, {progress: val});
        alert('Progression enregistrée');
      };

      // Analysis
      function fillSelects(){
        const a = $('img-a'), b = $('img-b');
        a.innerHTML=''; b.innerHTML='';
        for(const img of images){
          const label = `${img.original_name || img.filename} (${img.date})`;
          const o1 = document.createElement('option'); o1.value=img.id; o1.textContent=label; a.appendChild(o1);
          const o2 = document.createElement('option'); o2.value=img.id; o2.textContent=label; b.appendChild(o2);
        }
      }
      let pieInstance = null;
      $('btn-calc').onclick = async ()=>{
        const image_id_a = $('img-a').value; const image_id_b = $('img-b').value;
        const out = await postJSON('/api/analysis/diff', {image_id_a, image_id_b});
        $('diff-out').src = out.url;
        if(out.stats){
          const ctx = $('pie').getContext('2d');
          if(pieInstance) pieInstance.destroy();
          const values = [out.stats.faible||0, out.stats.moyen||0, out.stats.fort||0];
          pieInstance = new Chart(ctx, {
            type: 'pie',
            data: {
              labels: ['Faible', 'Moyen', 'Fort'],
              datasets: [{ data: values, backgroundColor: ['#a3e4d7','#f9e79f','#f5b7b1'] }]
            },
            options: { plugins: { legend: { position: 'bottom' } } }
          });
        }
      };

      // Courbes
      let chartInstance = null;
      async function updateChart(){
        if(!currentProject) return;
        // Planned: from start to end as linear progression by days
        const start = new Date(currentProject.start_date);
        const end = new Date(currentProject.end_date);
        const daysPlanned = Math.max(1, Math.round((end - start) / 86400000));
        const labels = Array.from({length: daysPlanned+1}, (_,i)=> i);
        const planned = labels.map((d)=> Math.round((d/daysPlanned)*100));

        // Observed: mark days that have images
        const dates = [...new Set(images.map(i=> i.date))].sort();
        const first = start; const last = end;
        const obs = labels.map(()=> null);
        for(const dt of dates){
          const d = Math.max(0, Math.min(daysPlanned, Math.round((new Date(dt) - first)/86400000)));
          obs[d] = Math.round((d/daysPlanned)*100);
        }

        const ctx = $('chart').getContext('2d');
        if(chartInstance) chartInstance.destroy();
        chartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              { label: 'Délai prévu', data: planned, borderColor: 'red', backgroundColor:'transparent' },
              { label: 'Délai observé', data: obs, borderColor: 'blue', backgroundColor:'transparent' }
            ]
          },
          options: { scales: { x: { title: { display:true, text: 'Jours'} }, y:{ min:0, max:100, ticks:{ stepSize: 10 } } } }
        });
      }

      // Docs
      async function loadDocs(){
        const docs = await fetchJSON('/api/docs');
        const box = $('docs');
        box.innerHTML = '';
        for(const d of docs){
          const a = document.createElement('a'); a.href = d.url; a.textContent = d.filename; a.target = '_blank'; a.style.display='block';
          box.appendChild(a);
        }
      }
      $('btn-doc-upload').onclick = async ()=>{
        const f = $('doc-file').files[0]; if(!f) return alert('Choisir un document');
        const fd = new FormData(); fd.append('file', f);
        const r = await fetch('/api/docs/upload', { method:'POST', body: fd });
        if(!r.ok) return alert('Echec import');
        await r.json();
        loadDocs();
      };

      // Init
      loadImages();
    </script>
  </body>
  </html>

