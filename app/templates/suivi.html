<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Suivi - GO-CHANTIER</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- georaster + GeoTIFF loader -->
  <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>
  <script src="https://unpkg.com/georaster@1.6.0/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet@3.12.0/dist/georaster-layer-for-leaflet.min.js"></script>

  <!-- Leaflet Draw for mesures -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- noUiSlider for timeline -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.css">
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.js"></script>

  <!-- Turf.js for géodésiques (surfaces) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{--bg:#0b1220;--panel:#0f172a;--muted:#94a3b8;--accent:#22c55e;--border:#1f2937}
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1220,#0f172a);color:#e5e7eb}
    .layout{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh}
    header,footer{background:rgba(17,24,39,.7);backdrop-filter: blur(10px);border-bottom:1px solid rgba(148,163,184,.12)}
    header{display:flex;gap:12px;align-items:center;padding:10px 14px}
    header h1{font-size:18px;margin:0 8px 0 0}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .btn{appearance:none;border:1px solid rgba(148,163,184,.18);background:#0b1220;color:#e5e7eb;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
    .btn:hover{border-color:rgba(148,163,184,.35)}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .controls{display:flex;gap:10px;align-items:center}
    .controls input[type=date]{background:#0b1220;border:1px solid rgba(148,163,184,.18);color:#e5e7eb;border-radius:10px;padding:8px}
    .controls input[type=file]{color:#e5e7eb}
    .content{display:grid;grid-template-columns:1fr 320px;gap:12px;padding:12px}
    #map{width:100%;height:calc(100vh - 190px);border:1px solid rgba(148,163,184,.12);border-radius:14px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
    .sidepanel{background:rgba(17,24,39,.6);border:1px solid rgba(148,163,184,.12);border-radius:14px;padding:12px;display:grid;gap:12px}
    .group{border:1px dashed rgba(148,163,184,.18);border-radius:12px;padding:10px}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    #timeline{margin:8px 0}
    .progress{display:flex;align-items:center;gap:8px}
    .progress-bar{flex:1;height:10px;background:#111827;border-radius:6px;overflow:hidden;border:1px solid rgba(148,163,184,.15)}
    .progress-bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#22c55e,#16a34a)}
    footer{border-top:1px solid rgba(148,163,184,.12);padding:8px 14px;color:var(--muted)}
    .badge{font-size:11px;color:#a3e635;background:#1a2e22;border:1px solid #1f7a41;padding:2px 8px;border-radius:999px}
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <h1>Suivi de chantier</h1>
      <div class="toolbar">
        <div class="controls">
          <label class="btn" for="geotiffInput">Importer GeoTIFF</label>
          <input id="geotiffInput" type="file" accept=".tif,.tiff" multiple style="display:none" />
          <input id="dateInput" type="date" />
          <button id="addDateBtn" class="btn">Ajouter date</button>
          <button id="addNoteBtn" class="btn">Ajouter commentaire</button>
        </div>
        <button id="prevBtn" class="btn">⟵ Revenir</button>
        <button id="nextBtn" class="btn">Avancer ⟶</button>
      </div>
    </header>

    <div class="content">
      <div id="map"></div>
      <aside class="sidepanel">
        <div class="group">
          <div class="label">Chronogramme (dates de prises de vue)</div>
          <div id="timeline"></div>
          <div id="timelineDates" class="label"></div>
        </div>
        <div class="group">
          <div class="label">Mesures</div>
          <div id="measurements" class="label">Aucune mesure</div>
        </div>
        <div class="group">
          <div class="label">Taux d'avancement</div>
          <div class="progress">
            <div class="progress-bar"><span id="progressFill"></span></div>
            <span id="progressText" class="badge">0%</span>
          </div>
        </div>
        <div class="group">
          <div class="label">Couches importées</div>
          <ul id="layersList" class="label" style="list-style:none;padding:0;margin:0;"></ul>
          <div class="label" id="selectedInfo">Aucune couche sélectionnée</div>
        </div>
      </aside>
    </div>

    <footer>
      Molette pour zoomer/dézoomer. Utilisez l'outil polyligne/polygone pour les mesures.
    </footer>
  </div>

  <script>
    // Map init
    const map = L.map('map', { zoomControl: true }).setView([5.35, -4.02], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 22, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Draw controls for measures
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
      draw: {
        marker: true, polyline: true, polygon: true, rectangle: true, circle: false, circlemarker: false
      },
      edit: { featureGroup: drawnItems }
    });
    map.addControl(drawControl);

    const measurementsBox = document.getElementById('measurements');
    function formatDistance(meters){
      if(meters < 1000) return meters.toFixed(1) + ' m';
      return (meters/1000).toFixed(2) + ' km';
    }
    function formatArea(sqm){
      if(sqm < 1e6) return sqm.toFixed(1) + ' m²';
      return (sqm/1e6).toFixed(2) + ' km²';
    }
    map.on(L.Draw.Event.CREATED, function (event) {
      const layer = event.layer;
      drawnItems.addLayer(layer);
      let text = '';
      if(layer instanceof L.Polygon || layer instanceof L.Rectangle){
        try{
          const latlngs = layer.getLatLngs()[0];
          const ring = latlngs.map(ll => [ll.lng, ll.lat]);
          if(ring.length && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])){
            ring.push([ring[0][0], ring[0][1]]);
          }
          const polygon = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [ring] } };
          const area = turf.area(polygon);
          text = 'Surface: ' + formatArea(area);
        } catch(err){
          text = 'Surface: non calculée';
        }
      } else if(layer instanceof L.Polyline){
        const latlngs = layer.getLatLngs();
        let dist = 0;
        for(let i=1;i<latlngs.length;i++){
          dist += latlngs[i-1].distanceTo(latlngs[i]);
        }
        text = 'Distance: ' + formatDistance(dist);
      } else if(layer instanceof L.Marker){
        text = 'Point ajouté';
      }
      measurementsBox.textContent = text || 'Mesure ajoutée';
    });

    // Import GeoTIFF logic
    const geotiffInput = document.getElementById('geotiffInput');
    const layersList = document.getElementById('layersList');
    const selectedInfo = document.getElementById('selectedInfo');
    const importedLayers = [];
    let selectedLayerIndex = null;
    geotiffInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      for (const file of files) {
        const arrayBuffer = await file.arrayBuffer();
        const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
        const image = await tiff.getImage();
        const georaster = await parseGeoraster(arrayBuffer);
        const layer = new GeoRasterLayer({
          georaster,
          opacity: 0.8,
          pixelValuesToColorFn: values => {
            const [v1,v2,v3] = values;
            const n = georaster.numberOfRasters;
            if(n >= 3){
              return `rgb(${v1||0}, ${v2||0}, ${v3||0})`;
            }
            const g = Math.min(255, Math.max(0, Math.round((v1||0))));
            return `rgb(${g}, ${g}, ${g})`;
          }
        });
        layer.addTo(map);
        const thisIndex = importedLayers.length;
        importedLayers.push({ name: file.name, layer, date: null });
        // fit map to layer
        const bounds = layer.getBounds();
        if(bounds && bounds.isValid()) map.fitBounds(bounds);
        // add UI item
        const li = document.createElement('li');
        li.style.padding = '6px 8px';
        li.style.borderRadius = '8px';
        li.style.cursor = 'pointer';
        li.dataset.index = String(thisIndex);
        li.innerHTML = `<input type="checkbox" checked /> <span class="layer-name">${file.name}</span> <span class="layer-date"></span>`;
        const chk = li.querySelector('input');
        chk.addEventListener('change', () => {
          if(chk.checked) layer.addTo(map); else map.removeLayer(layer);
        });
        li.addEventListener('click', (ev)=>{
          if(ev.target.tagName && ev.target.tagName.toLowerCase()==='input') return;
          const allItems = layersList.querySelectorAll('li');
          allItems.forEach(el=>{ el.style.background=''; el.style.border=''; });
          li.style.background = 'rgba(148,163,184,.08)';
          li.style.border = '1px solid rgba(148,163,184,.25)';
          selectedLayerIndex = Number(li.dataset.index);
          const layerObj = importedLayers[selectedLayerIndex];
          selectedInfo.textContent = `Sélection: ${layerObj.name}` + (layerObj.date? ` — ${new Date(layerObj.date).toLocaleDateString()}` : '');
        });
        layersList.appendChild(li);
        if(selectedLayerIndex === null){
          li.click();
        }
      }
      refreshTimelineFromLayers();
      refreshProgress();
    });

    // Timeline management
    const dateInput = document.getElementById('dateInput');
    const addDateBtn = document.getElementById('addDateBtn');
    const addNoteBtn = document.getElementById('addNoteBtn');
    const timeline = document.getElementById('timeline');
    const timelineDates = document.getElementById('timelineDates');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');

    let slider;
    let timelineData = [];// [{date: Date, name: string, index: number}]
    function renderTimeline(){
      if(!timelineData.length){
        timeline.innerHTML = '<div class="label">Ajoutez des dates pour activer le chronogramme.</div>';
        timelineDates.textContent = '';
        return;
      }
      timelineData.sort((a,b)=> a.date - b.date);
      timeline.innerHTML = '';
      slider = noUiSlider.create(timeline, {
        start: 0,
        step: 1,
        connect: [true, false],
        range: { min: 0, max: timelineData.length-1 },
        tooltips: true,
        format: {
          to: (v)=> new Date(timelineData[Math.round(v)].date).toISOString().slice(0,10),
          from: (v)=> v
        }
      });
      slider.on('update', ()=> {
        const idx = Math.round(Number(slider.get(true)));
        const item = timelineData[idx];
        timelineDates.textContent = `Sélection: ${new Date(item.date).toLocaleDateString()} — ${item.name}`;
      });
    }

    function refreshTimelineFromLayers(){
      timelineData = importedLayers
        .map((l,idx)=> l.date ? { date: new Date(l.date), name: l.name, index: idx } : null)
        .filter(Boolean);
      renderTimeline();
    }

    addDateBtn.addEventListener('click', ()=>{
      if(!dateInput.value) return alert('Choisissez une date');
      const d = new Date(dateInput.value);
      if(isNaN(+d)) return alert('Date invalide');
      if(selectedLayerIndex === null) return alert('Sélectionnez une couche à dater.');
      importedLayers[selectedLayerIndex].date = d;
      const li = layersList.children[selectedLayerIndex];
      if(li){
        const dateSpan = li.querySelector('.layer-date');
        if(dateSpan) dateSpan.textContent = ` — ${d.toISOString().slice(0,10)}`;
      }
      selectedInfo.textContent = `Sélection: ${importedLayers[selectedLayerIndex].name} — ${d.toLocaleDateString()}`;
      refreshTimelineFromLayers();
      refreshProgress();
    });

    // Add note as speech bubble
    addNoteBtn.addEventListener('click', ()=>{
      const note = prompt('Votre commentaire:');
      if(!note) return;
      const center = map.getCenter();
      const marker = L.marker(center).addTo(map);
      marker.bindTooltip(note, { permanent: true, direction: 'top', className: 'note-bubble' }).openTooltip();
    });

    // Prev / Next controls switch the selected timeline index
    function changeIndex(delta){
      if(!slider) return;
      const idx = Math.round(Number(slider.get(true)));
      const next = Math.min(Math.max(idx + delta, 0), timelineData.length-1);
      slider.set(next);
    }
    prevBtn.addEventListener('click', ()=> changeIndex(-1));
    nextBtn.addEventListener('click', ()=> changeIndex(1));

    // Progress: % de couches avec une date affectée
    function refreshProgress(){
      const total = importedLayers.length;
      if(total === 0){
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
        return;
      }
      const done = importedLayers.filter(l=> !!l.date).length;
      const pct = Math.round((done / total) * 100);
      progressFill.style.width = pct + '%';
      progressText.textContent = pct + '%';
    }
  </script>

  <style>
    .note-bubble{
      background:#111827;color:#e5e7eb;border:1px solid rgba(148,163,184,.2);border-radius:10px;padding:6px 10px;box-shadow:0 6px 20px rgba(0,0,0,.35)
    }
  </style>
</body>
</html>
